<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Open Source ZIP Maker (No Dependencies)</title>
<style>
  :root {
    color-scheme: light dark;
    --bg: #0b0c10;
    --panel: #121318;
    --text: #e6e6e6;
    --accent: #3fa7ff;
    --muted: #9aa4ad;
    --border: #2a2f36;
  }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    background: var(--bg); color: var(--text);
  }
  header {
    padding: 1.25rem 1rem; border-bottom: 1px solid var(--border); background: var(--panel);
  }
  h1 { margin: 0 0 .5rem 0; font-size: 1.25rem; }
  .wrap { max-width: 920px; margin: 0 auto; padding: 1rem; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }
  .card {
    background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 1rem;
  }
  label { display: block; font-weight: 600; margin-bottom: .5rem; color: var(--muted); }
  input[type="text"] {
    width: 100%; padding: .6rem .7rem; background: transparent; border: 1px solid var(--border);
    border-radius: 8px; color: var(--text);
  }
  input[type="file"] { width: 100%; }
  .drop {
    border: 2px dashed var(--border); border-radius: 12px; padding: 1.25rem; text-align: center;
    transition: border-color .2s, background-color .2s;
  }
  .drop.drag {
    border-color: var(--accent);
    background: color-mix(in oklab, var(--panel) 80%, var(--accent));
  }
  button {
    background: var(--accent); color: #06131f; border: none; border-radius: 10px;
    padding: .7rem 1rem; font-weight: 700; cursor: pointer;
  }
  button[disabled] { opacity: .5; cursor: not-allowed; }
  .files {
    max-height: 240px; overflow: auto; border: 1px solid var(--border); border-radius: 8px; padding: .5rem;
    background: #0f1015;
  }
  .file { display: flex; gap: .5rem; align-items: center; justify-content: space-between; padding: .35rem .5rem; border-bottom: 1px dashed var(--border); }
  .file:last-child { border-bottom: none; }
  .name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .size { color: var(--muted); font-variant-numeric: tabular-nums; }
  .actions { display: flex; gap: .5rem; }
  .muted { color: var(--muted); }
  .progress { margin-top: .5rem; height: 8px; background: #1b1f27; border-radius: 999px; overflow: hidden; }
  .bar { height: 100%; width: 0%; background: var(--accent); transition: width .15s; }
  footer { padding: 1rem; text-align: center; color: var(--muted); font-size: .9rem; }
  a { color: var(--accent); }
  .mini { font-size: .85rem; }
</style>
</head>
<body>
<header class="wrap">
  <h1>Open Source ZIP Maker (No Dependencies)</h1>
  <div class="muted mini">Client-side ZIP builder using stored entries (no compression). Drag files, name the archive, and create your ZIP.</div>
</header>

<main class="wrap">
  <div class="row">
    <div class="card">
      <label>Add files</label>
      <input id="picker" type="file" multiple />
      <div id="drop" class="drop" style="margin-top:.75rem;">
        Drop files here or click “Add files”
      </div>
      <div class="progress" aria-hidden="true"><div id="bar" class="bar"></div></div>
      <div id="status" class="muted mini" style="margin-top:.5rem;">Idle</div>
    </div>
    <div class="card">
      <label>Archive name</label>
      <input id="zipname" type="text" placeholder="my-archive.zip" />
      <div class="actions" style="margin-top:.75rem;">
        <button id="make" disabled>Create ZIP</button>
        <button id="clear" disabled>Clear</button>
      </div>
      <div class="muted mini" style="margin-top:.5rem;">
        Files are stored without compression (fast, consistent). CRC32 and timestamps are preserved.
      </div>
    </div>
  </div>

  <div class="card">
    <label>Files to include</label>
    <div id="list" class="files" aria-live="polite"></div>
  </div>
</main>

<footer>
  Made with care. MIT Licensed. You can use, modify, and integrate freely.
</footer>

<script>
/* ===== CRC32 (IEEE 802.3) ===== */
const CRC_TABLE = (() => {
  const table = new Uint32Array(256);
  for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
      c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    }
    table[n] = c >>> 0;
  }
  return table;
})();

function crc32(buf) {
  let c = 0xFFFFFFFF;
  const u8 = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
  for (let i = 0; i < u8.length; i++) {
    c = CRC_TABLE[(c ^ u8[i]) & 0xFF] ^ (c >>> 8);
  }
  return (c ^ 0xFFFFFFFF) >>> 0;
}

/* ===== DOS time/date from JS Date ===== */
function toDosTimeDate(date) {
  const d = new Date(date);
  const sec = Math.floor(d.getSeconds() / 2); // DOS stores seconds / 2
  const min = d.getMinutes();
  const hour = d.getHours();
  const day = d.getDate();
  const month = d.getMonth() + 1;
  const year = d.getFullYear();
  const dosTime = (hour << 11) | (min << 5) | (sec);
  const dosDate = ((year - 1980) << 9) | (month << 5) | (day);
  return { dosTime, dosDate };
}

/* ===== Byte helpers ===== */
function u8Concat(chunks, totalLen) {
  const out = new Uint8Array(totalLen);
  let offset = 0;
  for (const c of chunks) {
    out.set(c, offset);
    offset += c.length;
  }
  return out;
}

function writeU32LE(val) {
  const b = new Uint8Array(4);
  b[0] = val & 0xFF;
  b[1] = (val >>> 8) & 0xFF;
  b[2] = (val >>> 16) & 0xFF;
  b[3] = (val >>> 24) & 0xFF;
  return b;
}

function writeU16LE(val) {
  const b = new Uint8Array(2);
  b[0] = val & 0xFF;
  b[1] = (val >>> 8) & 0xFF;
  return b;
}

/* ===== ZIP builder (stored entries) ===== */
async function buildZip(files) {
  // Each entry: local header + data; Track central directory entries
  const localChunks = [];
  const centralChunks = [];
  let offset = 0; // offset of local header from start of file
  let totalLocalLen = 0;
  let totalCentralLen = 0;

  for (let idx = 0; idx < files.length; idx++) {
    const f = files[idx];
    const name = f.webkitRelativePath || f.name;
    const nameBytes = new TextEncoder().encode(name);

    // Read file data
    const buf = await f.arrayBuffer();
    const data = new Uint8Array(buf);
    const size = data.length >>> 0;
    const crc = crc32(data);
    const { dosTime, dosDate } = toDosTimeDate(f.lastModified || Date.now());

    // Local file header
    const lfHeader = [
      writeU32LE(0x04034b50),       // signature
      writeU16LE(20),               // version needed to extract
      writeU16LE(0),                // general purpose bit flag
      writeU16LE(0),                // compression method: 0 (stored)
      writeU16LE(dosTime),          // last mod file time
      writeU16LE(dosDate),          // last mod file date
      writeU32LE(crc),              // CRC-32
      writeU32LE(size),             // compressed size
      writeU32LE(size),             // uncompressed size
      writeU16LE(nameBytes.length), // file name length
      writeU16LE(0)                 // extra field length
    ];

    const localPart = u8Concat(
      [...lfHeader, nameBytes, data],
      lfHeader.reduce((s, b) => s + b.length, 0) + nameBytes.length + data.length
    );

    localChunks.push(localPart);
    totalLocalLen += localPart.length;

    // Central directory header
    const cdHeader = [
      writeU32LE(0x02014b50),       // central file header signature
      writeU16LE(20),               // version made by
      writeU16LE(20),               // version needed to extract
      writeU16LE(0),                // general purpose bit flag
      writeU16LE(0),                // compression method
      writeU16LE(dosTime),          // last mod time
      writeU16LE(dosDate),          // last mod date
      writeU32LE(crc),              // CRC-32
      writeU32LE(size),             // compressed size
      writeU32LE(size),             // uncompressed size
      writeU16LE(nameBytes.length), // file name length
      writeU16LE(0),                // extra field length
      writeU16LE(0),                // file comment length
      writeU16LE(0),                // disk number start
      writeU16LE(0),                // internal file attributes
      writeU32LE(0),                // external file attributes
      writeU32LE(offset)            // relative offset of local header
    ];

    const centralPart = u8Concat(
      [...cdHeader, nameBytes],
      cdHeader.reduce((s, b) => s + b.length, 0) + nameBytes.length
    );

    centralChunks.push(centralPart);
    totalCentralLen += centralPart.length;

    offset += localPart.length;
    updateProgress(idx + 1, files.length, `Added: ${name}`);
    await microYield(); // keep UI responsive
  }

  // End of central directory
  const eocd = [
    writeU32LE(0x06054b50),     // end of central dir signature
    writeU16LE(0),              // number of this disk
    writeU16LE(0),              // number of the disk with the start of the central directory
    writeU16LE(files.length),   // total number of entries in the central dir on this disk
    writeU16LE(files.length),   // total number of entries in the central dir
    writeU32LE(totalCentralLen),// size of the central directory
    writeU32LE(totalLocalLen),  // offset of start of central directory (immediately after local chunks)
    writeU16LE(0)               // .ZIP file comment length
  ];
  const eocdPartLen = eocd.reduce((s, b) => s + b.length, 0);
  const eocdPart = u8Concat(eocd, eocdPartLen);

  const zipLen = totalLocalLen + totalCentralLen + eocdPart.length;
  const zipBytes = u8Concat([...localChunks, ...centralChunks, eocdPart], zipLen);
  return new Blob([zipBytes], { type: "application/zip" });
}

/* ===== UI wiring ===== */
const listEl = document.getElementById('list');
const pickerEl = document.getElementById('picker');
const dropEl = document.getElementById('drop');
const makeEl = document.getElementById('make');
const clearEl = document.getElementById('clear');
const statusEl = document.getElementById('status');
const barEl = document.getElementById('bar');
const nameEl = document.getElementById('zipname');

let files = [];

pickerEl.addEventListener('change', (e) => {
  addFiles([...e.target.files]);
});

['dragenter', 'dragover'].forEach(evt =>
  dropEl.addEventListener(evt, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropEl.classList.add('drag');
  })
);
['dragleave', 'drop'].forEach(evt =>
  dropEl.addEventListener(evt, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropEl.classList.remove('drag');
  })
);
dropEl.addEventListener('drop', (e) => {
  const items = e.dataTransfer?.files ? [...e.dataTransfer.files] : [];
  addFiles(items);
});

makeEl.addEventListener('click', async () => {
  if (!files.length) return;
  try {
    setBusy(true, 'Building ZIP…');
    const blob = await buildZip(files);
    const name = normalizeZipName(nameEl.value) || defaultZipName();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setBusy(false, `ZIP ready: ${name}`);
    // Keep object URL alive briefly to avoid revoke race; revoke later
    setTimeout(() => URL.revokeObjectURL(url), 4000);
  } catch (err) {
    console.error(err);
    setBusy(false, 'Error building ZIP (see console)');
  }
});

clearEl.addEventListener('click', () => {
  files = [];
  pickerEl.value = '';
  renderList();
  makeEl.disabled = true;
  clearEl.disabled = true;
  setBusy(false, 'Cleared');
});

function addFiles(add) {
  // Deduplicate by (name + size + lastModified)
  const key = f => `${f.webkitRelativePath || f.name}::${f.size}::${f.lastModified}`;
  const existing = new Set(files.map(key));
  for (const f of add) {
    const k = key(f);
    if (!existing.has(k)) files.push(f);
  }
  renderList();
  makeEl.disabled = files.length === 0;
  clearEl.disabled = files.length === 0;
}

function renderList() {
  listEl.innerHTML = '';
  if (!files.length) {
    listEl.innerHTML = '<div class="muted mini">No files added yet.</div>';
    return;
  }
  for (let i = 0; i < files.length; i++) {
    const f = files[i];
    const row = document.createElement('div');
    row.className = 'file';
    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = f.webkitRelativePath || f.name;
    const size = document.createElement('div');
    size.className = 'size';
    size.textContent = humanSize(f.size);
    const x = document.createElement('button');
    x.textContent = 'Remove';
    x.addEventListener('click', () => {
      files.splice(i, 1);
      renderList();
      makeEl.disabled = files.length === 0;
      clearEl.disabled = files.length === 0;
    });
    row.appendChild(name);
    row.appendChild(size);
    row.appendChild(x);
    listEl.appendChild(row);
  }
}

function humanSize(n) {
  const k = 1024;
  if (n < k) return `${n} B`;
  const units = ['KB','MB','GB','TB'];
  let i = -1, v = n;
  do { v /= k; i++; } while (v >= k && i < units.length - 1);
  return `${v.toFixed(v >= 100 ? 0 : v >= 10 ? 1 : 2)} ${units[i]}`;
}

function updateProgress(done, total, msg) {
  const pct = total ? Math.round((done / total) * 100) : 0;
  barEl.style.width = pct + '%';
  statusEl.textContent = msg + ` (${pct}%)`;
}

function setBusy(busy, msg) {
  if (busy) {
    makeEl.disabled = true;
    clearEl.disabled = true;
  } else {
    makeEl.disabled = files.length === 0;
    clearEl.disabled = files.length === 0;
    barEl.style.width = '0%';
  }
  statusEl.textContent = msg || (busy ? 'Working…' : 'Idle');
}

function defaultZipName() {
  const d = new Date();
  const pad = (n) => String(n).padStart(2, '0');
  return `archive-${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.zip`;
}

function normalizeZipName(str) {
  if (!str) return '';
  let s = str.trim();
  if (!s) return '';
  s = s.replace(/[\\/:*?"<>|]+/g, '-');
  if (!/\.zip$/i.test(s)) s += '.zip';
  return s;
}

function microYield() {
  return new Promise(requestAnimationFrame);
}
</script>
</body>
</html>
